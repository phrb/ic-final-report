\documentclass[a4paper, 11pt, twoside]{article}

\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{a4wide}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{textcomp}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\pdobject}[1]{\begin{center}\fbox{\texttt{#1}}\end{center}}

\begin{document}

\hypersetup{backref,pdfpagemode=FullScreen,colorlinks=true}

\input{./title.tex}

\tableofcontents
\newpage

\begin{abstract}
\line(1,0){350}

A adaptabilidade em tempo real e o potencial de modelagem de sistemas complexos
são características de Sistemas Multiagentes, que têm variadas aplicações no 
contexto musical. A ferramenta de criação musical e linguagem de programação 
Pure Data (Pd) é tradicionalmente utilizada por músicos em performances 
musicais. Este projeto produziu uma integração do arcabouço para Sistemas
Multiagentes Musicais Ensemble - implementado pelo Grupo de Computação Musical 
do IME/USP - com a libpd, uma infraestrutura do tipo API para Pure Data. 
A integração procura facilitar a utilização do arcabouço por usuários 
não programadores. A interface é uma extensão do Arcabouço Ensemble,
e permite desenvolver aplicações do Arcabouço através do ambiente gráfico
do Pure Data.

\line(1,0){350}
\end{abstract}

\begin{multicols}{2}

\section{Introdução}

Este relatório descreve e detalha as atividades desenvolvidas no período de 
Fevereiro a Julho de 2014, sumarizadas a seguir.

O aluno apresentou um seminário sobre o trabalho desenvolvido na elaboração da 
interface entre a linguagem de programação Pure Data e o Arcabouço Ensemble, 
no ciclo aberto de seminários do Grupo de Computação Musical.

Elaborou-se um protocolo de comunicação entre o Arcabouço Ensemble e o
Pure Data, permitindo a comunicação entre \textit{patches} e o Arcabouço.

A interface de comunicação básica implementada no semestre passado foi
largamente extendida durante este semestre, permitindo a definição de
Agentes Musicais, seus Raciocínios e Componentes e até aplicações
completas do Arcabouço Ensemble através de \textit{patches} Pure Data.

Submetemos um artigo para a Conferência Conjunta ICMC/SMC 2014~\cite{},
detalhando o protocolo e a interface desenvolvidos. O artigo foi aceito
para publicação e apresentação oral na Conferência.

As próximas seções apresentam o detalhamento destas atividades.

\section{O Protocolo}

With the libpd Java bindings, it is possible to divert all requests to any 
given agent reasoning (in Java) to a call to libpd that causes a Pd patch 
to be executed, and to collect any data produced by this patch back to 
the reasoning for further processing by Ensemble (through its actuators, 
event servers, etc). In such a context the Java-written reasoning is 
nothing more than a generic \emph{wrapper} that requires only a 
few parameter inputs (e.g. the Pd patch filename that contains 
the actual reasoning).

In order for this wrapper-reasoning to work, the Pd patch has to adhere to a 
certain protocol, using specific Pd objects and a well-defined syntax to 
gain access to the structures contained in the agent's representation in 
Ensemble. This protocol should define Pd objects for accessing and modifying 
memories corresponding to existing sensors and actuators and for retrieving 
and storing data in a knowledge base, which are essential operations in 
the design of any reasoning. Furthermore, this protocol should also specify 
Pd objects to create and modify agents and components, and also to define 
characteristics of the virtual world that were formerly configured 
in an XML initialization file.

This protocol, defined in the sequel, should aim at complete transparency 
(from the user point-of-view) with respect to inner workings of the Ensemble 
framework, that will still be carried out by its Java kernel. In practical 
terms, no knowledge of the Ensemble Java classes and code should be required 
from the user of Ensemble through this Pd Ensemble protocol. Ideally, the Pd 
Ensemble user should not be even aware that any data is coming from or 
going to the Ensemble Java kernel outside Pd.

\subsection{Environment}

Ensemble applications can be configured and initialized by an XML file parsed 
by a loader class, where the user defines the application's components, such 
as Event Servers, Worlds and its Laws, Musical Agents and their Sensors and 
Actuators. The Ensemble-Pd interface allows these configuration parameters to 
be defined by message arguments sent to symbols that Ensemble subscribe to. 
These messages should be sent at the moment the patch is loaded by Ensemble's 
Pd instance.

Messages sent to the \textbf{global} symbol define Ensemble's clock, 
schedule and process modes; messages sent to the \textbf{environment} 
symbol define the Environment Agent, World and Laws; and messages sent to 
the \textbf{add\_agent} symbol define Musical Agent names that will be added 
to the application, and whose definition should be in subpatches inside the 
configuration patch. Table\ref{tab:startupsymbols} shows the Pd symbols and 
objects used in the initialization, their arguments and usage.

\end{multicols}

\begin{table}[h]
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            Symbol/Object & Arguments & Usage \\
            \hline
        \textbf{global} & \begin{tabular}[c]{@{}l@{}}<clock\_mode>\\<process\_mode>\\<scheduler\_threads>\end{tabular} & \begin{tabular}[c]{@{}l@{}}Sets\\execution\\parameters\end{tabular} \\
            \hline   
        \textbf{environment} & \begin{tabular}[c]{@{}l@{}}<class>\\<world>\\<\textit{world\_class}>\\ {[}<\textit{world\_law}>]\end{tabular} & \begin{tabular}[c]{@{}l@{}}Sets\\environment\\and world\\parameters\end{tabular} \\
            \hline
        \textbf{add\_agent} & <name> & \begin{tabular}[c]{@{}l@{}}Adds\\an Agent\end{tabular}\\
            \hline
        \textbf{[r <\textit{agent}>/start]} & & \begin{tabular}[c]{@{}l@{}}Receives\\agent\\startup bang\end{tabular} \\
            \hline   
        \end{tabular}
    \end{center}
    \caption{Application Startup Symbols.}
    \label{tab:startupsymbols}
\end{table}

\begin{multicols}{2}

\subsection{Sensors and Actuators}

Every Musical Agent added to the Pd application has its own subpatch, where 
its Reasoning, Actuators, Sensors, Memories and Knowledge Base are defined and 
configured via messages, which are sent to Ensemble symbols when the framework 
is ready to start processing that Agent. This is done to prevent Ensemble from 
losing the agent configuration messages, because at the moment of loading the 
patch Ensemble has not yet received the agents' names, and so could not have 
subscribed to their symbols. Table\ref{tab:actuatorsandsensors} shows the Pd 
symbols and objects used in Sensor and Actuator creation and communication, 
their arguments and usage.

\end{multicols}

\begin{table}[h]
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            Symbol/Object & Arguments & Usage \\
            \hline
        \textbf{add\_actuator} & \begin{tabular}[c]{@{}l@{}}<name>\\<type>\\ {[}<scope>]\end{tabular} & Adds a new Actuator \\
            \hline   
        \textbf{add\_sensor} & \begin{tabular}[c]{@{}l@{}}<name>\\<type>\\ {[}<scope>]\end{tabular} & Adds a new Sensor \\
            \hline
            \textbf{remove\_actuator} & <name> & Removes an Actuator \\
            \hline
            \textbf{remove\_sensor} & <name> & Removes a Sensor \\
            \hline
        \textbf{[s \textit{actuator\_name}]} & \begin{tabular}[c]{@{}l@{}}<data>\\ {[}<scope>]\end{tabular} & \begin{tabular}[c]{@{}l@{}}Writes data \\ to \textit{actuator\_name}\end{tabular} \\
            \hline
        \textbf{[r \textit{sensor\_name}]} & & \begin{tabular}[c]{@{}l@{}}Receives data\\from \textit{sensor\_name}\end{tabular} \\
            \hline
        \end{tabular}
    \end{center}
    \caption{Actuators and Sensors Symbols.}
    \label{tab:actuatorsandsensors}
\end{table}

\begin{multicols}{2}

Ensemble starts agent processing by sending (through libpd) a bang to the 
symbol \texttt{<\textit{agent}>/start} (see Table\ref{tab:startupsymbols}) 
which will be received in the application's patch by a Pd object 
\pdobject{r <\textit{agent}>/start} Messages in the patch connected to this 
object should contain the names and parameters for the desired components and 
Knowledge Base facts. Messages in the patch sent to the symbol corresponding 
to the agent name are used to create components; for instance sending a 
message to a symbol \texttt{<agent>} with contents \textbf{add\_actuator} 
or \textbf{add\_sensor} initialize (in Ensemble) the corresponding Sensors 
and Actuators, and also define the type of Event that this component will 
handle; optionally this message can define a scope, allowing for private 
communication between selected actuators and sensors.

\subsection{Knowledge Base}

Adding facts to the Knowledge Base at agent startup time is done by sending a 
message with the fact name and value to the symbol \textbf{new\_fact}. 
Facts can later be recovered by sending messages to the object 
\pdobject{read\_fact <agent\_name>} which receives a fact name in its 
inlet and returns the value in its outlet (assuming the fact exists in the 
agent's Knowledge Base). Updating the fact in the agent's Knowledge Base 
is done via messages to the object \pdobject{update\_fact <agent\_name>} that 
receives a fact name and new value in its inlet and updates the Knowledge Base 
accordingly. In Table\ref{tab:kbprotocol} are the Pd symbols and objects used in 
creating, accessing, removing and updating a fact in the Agent's Knowledge 
Base, their arguments and usage.

\end{multicols}

\begin{table}[h]
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            Symbol/Object & Arguments & Usage \\
            \hline
        \textbf{new\_fact} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<value>\end{tabular} & Adds a new Fact\\
            \hline   
        \textbf{update\_fact} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<value>\end{tabular} & \begin{tabular}[c]{@{}l@{}}Updates a\\fact if it\\exists\end{tabular}\\
            \hline
            \textbf{remove\_fact} & name & Removes a Fact\\
            \hline
        \textbf{[read\_fact]} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<value>\end{tabular}
                              & \begin{tabular}[c]{@{}l@{}}Reads a \\Fact and\\returns a value\end{tabular}\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Knowledge Base Symbols.}
    \label{tab:kbprotocol}
\end{table}

\begin{multicols}{2}

\subsection{Memories}

In the same way, different types of Agent Memories can be created and read 
from with messages to the symbols \textbf{new\_memory} and 
\textbf{read\_memory}. To read from a memory, a message must specify a 
memory name and a time value; when writing to a memory (e.g. an actuator's 
memory), the value sent to the symbol \textbf{write\_memory} is written in the 
specified Memory at the current processing time. Table\ref{tab:memprotocol} 
presents the Pd symbols and objects used in Memory creation, writing and 
reading, their arguments and usage.

\end{multicols}

\begin{table}[h]
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            Symbol/Object & Arguments & Usage \\
            \hline
        \textbf{new\_memory} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<type>\\\end{tabular} & Adds a new Memory \\
            \hline 
        \textbf{write\_memory} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<value>\end{tabular} & \begin{tabular}[c]{@{}l@{}}Writes to a \\Memory at\\current time\end{tabular} \\
            \hline
        \textbf{read\_memory} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<time>\end{tabular} & \begin{tabular}[c]{@{}l@{}}Reads a \\Memory and\\returns a value\end{tabular} \\
            \hline
        \end{tabular}
    \end{center}
    \caption{Memory Symbols.}
    \label{tab:memprotocol}
\end{table}

\begin{multicols}{2}

\section{A Interface}

A interface implementada é composta de uma extensão do Arcabouço Ensemble,
que consiste de várias classes Java e de algumas abstrações Pure Data.
Esta seção descreve com detalhes a implementação das classes e abstrações,
e discute os problemas encontrados e as soluções adotadas.

\subsection{Classes Java}

Esta seção apresenta uma descrição detalhada da interface Ensemble-Pd,
justificando as principais classes Java utilizadas, expondo suas 
interrelações e contextualizando seu papel no funcionamento de aplicações
do Ensemble.

\subsubsection{PdAgent}

Esta classe é uma extensão da classe \textbf{MusicalAgent} do Ensemble,
e suas instâncias representam agentes musicais numa aplicação.
O mapeamento de um agente definido num \textit{patch} e sua representação no 
Ensemble é feito através dessa classe.

A classe \textbf{PdAgentClassInformation} encapsula informações sobre
instâncias de Agentes definidas no \textit{patch}, que são utilizadas na
inicialização do Ensemble para instanciar e cadastrar esses Agentes no
JADE.

Os componentes de um Agente, como Raciocínio, Atuadores e Sensores, são
adicionados a \textbf{PdAgent} através de mensagens definidas dentro do
\textit{patch}. Atuadores e Sensores são representados pelas classes 
\textbf{PdActuator} e \textbf{PdSensor}, respectivamente.

O Servidor de Eventos de uma aplicação Ensemble-Pd é responsável por garantir 
que a representação de um Agente num \textit{patch} receba e envie Eventos, 
Mensagens e Áudio de e para o Ambiente Virtual e outros Agentes. Isso é feito
através de Sensores e Atuadores especiais, inseridos por padrão em instâncias
de \textbf{PdAgent}, e que permitem essa comunicação.

\subsubsection{PdReasoning}

O raciocínio de um Agente numa aplicação Ensemble-Pd é definido dentro do
\textit{subpatch}/abstração correspondente a esse Agente, e consiste de
uma aplicação Pd que pode conter qualquer objeto Pd utilizado em aplicações
tradicionais. De dentro do \textit{patch} de Raciocínio, o programador Pd tem 
acesso à informação recebida pelo Agente através dos Sensores que ele definiu,
podendo utilizar os recursos de Processamento de Sinais implementados no Pure
Data para produzir e processar amostras de áudio e demais informações 
recebidas, e pode atuar no Ambiente Virtual através dos Atuadores do Agente.

\subsubsection{PdEvent}

Esta classe encapsula, no funcionamento de uma aplicação Ensemble,
as mensagens e informações provenientes e destinadas a \textit{patches} Pd.

Os tipos manipulados por esta classe são \textbf{PdFloat}, \textbf{PdMessage} e
\textbf{PdAudioBlock}, que por sua vez encapsulam os diferentes tipos de dados
tratados pelo Pure Data.

\subsubsection{PdServer}

Esta é a principal classe do ponto de vista da sincronização 
e mapeamento entre \textit{patches} e aplicações Ensemble.
Ela é quem centraliza e coordena a execução de um \textit{patch}, utilizando
a classe \textbf{PdProcessor}, e processa as mensagens e dados recebidos do Pd 
através da classe \textbf{PdReceiver}, produzindo Eventos para os Sensores 
dos Agentes a que essas mensagens se destinam.

Além disso, é ela quem processa os Eventos enviados por Atuadores de Agentes,
reproduzindo no \textit{patch} as mudanças feitas pelos Agentes.

\subsubsection{PdReceiver}

Esta é uma extensão da classe \textbf{PdDispatcher} contida na implementação
Java da libpd, e encapsula as funções de \textit{callback} usadas na
comunicação entre \textit{patches} e aplicações que usam a libpd.

Esta classe também é responsável por registrar e gerenciar símbolos
usados na comunicação do Ensemble com o \textit{patch}, centralizando
o envio e recebimento de mensagens, áudio e demais informações.

A padronização dos símbolos utilizados nos componentes e mensagens
de uma aplicação Ensemble-Pd permite que o ciclo de processamento
dos \textit{patches} de aplicação seja centralizado pela classe
\textbf{PdServer}, pois garante que não haverão ambiguidades entre
destinatários/remetentes e que nenhuma mensagem será perdida
entre ciclos de processamento.

\subsubsection{PdAudioBlock}

Durante a implementação da interface, desenvolvemos duas diferentes estratégias
para a transferência de amostras de áudio entre o \textit{patch} e o Ensemble, 
uma centralizada e uma distribuída, finalmente optando pela centralização 
do ciclo de processamento na classe \textbf{PdServer}.

A estratégia distribuída consistia na descentralização dos ciclos de
processamento da libpd, permitindo que cada Raciocínio de um Agente
inserido numa aplicação processasse seu \textit{subpatch} independentemente,
tratando suas próprias mensagens e amostras de áudio separadamente.

Essa estratégia gera problemas de sincronização de Eventos e Áudio,
decorrentes do funcionamento dos dois softwares envolvidos.

As amostras de áudio produzidas num mesmo momento pelos Agentes 
num \textit{patch} devem ser tocadas como seriam num \textit{patch}
processado pelo Pd, e as mensagens enviadas pelos Agentes devem obedecer
uma sequência definida pelo Raciocínio, também definido num \textit{patch}.
Se cada Agente é capaz de processar o \textit{patch} de aplicação
no seu ciclo de processamento no Ensemble, não é possível garantir que ele
não receberá ou enviará Eventos ou Áudio somente após todos os outros Agentes 
recebam seu "turno" de Eventos, pois o controle de tempo execução dos Agentes 
é feito pelo middleware JADE, e não tem conexão com o ciclo de processamento
da libpd.

Como o \textit{patch} de configuração de aplicação é único, o controle de
processamento descentralizado produz desencontros nas amostras de Áudio, 
e também no fluxo de Eventos da aplicação.

A solução de processamento centralizado resolve estes problemas utilizando
as abstrações Pd \textbf{act\textasciitilde} e \textbf{sense\textasciitilde},
e as classes Java \textbf{PdAudioBlock} e \textbf{PdAudioBlockStream}.

Essas classes representam um bloco de processamento do Pure Data, e um
encadeamento temporal desses blocos, respectivamente. Elas permitem
receber amostras de Áudio de cada Atuador independentemente, e enviar
amostras a Sensores de forma sincronizada, pois cada Sensor e Atuador
tem seu próprio \textbf{PdAudioBlockStream}.

O Servidor de Eventos pode então enviar e receber Áudio e Eventos de Agentes,
mantendo a sincronia entre a execução do Ensemble e o processamento 
do \textit{patch}.

\subsection{Abstrações no Pure Data}

Em conjunto com as classes Java foram implementadas abstrações do
Pure Data, que são facilitadores da comunicação entre Ensemble e Pd
e encapsulam o uso dos componentes de baixo-nível fornecidos pela
interface Ensemble-libpd em  novos componentes de alto-nível
na forma de objetos Pure Data.

O programador Pd pode então utilizar esses objetos para se comunicar
com o Ensemble utilizando as convenções da linguagem Pure Data,
sem se preocupar com detalhes de implementação da interface com o
Ensemble.

\subsubsection{act\textasciitilde e sense\textasciitilde}

Um Atuador de um Agente numa aplicação é representado pela abstração
\textbf{act\textasciitilde}, e recebe através de um \textit{inlet} 
um sinal de Áudio que será propagados no Ambiente 
Virtual e percebidos por outros Agentes de acordo com as regras da aplicação. 
De forma análoga, a abstração \textbf{sense\textasciitilde} possui um 
\textit{outlet} através do qual o \textit{patch} recebe os sinais de Áudio 
percebidos pelo Agente correspondente.

As abstrações \textbf{act} e \textbf{sense}, seguindo a convenção de nomes do
Pure Data, são utilizadas para a comunicação dos demais tipos de dados.

\subsubsection{read\_memory\textasciitilde e read\_fact}

Estas abstrações são utilizadas para acessar informações da Base
de Conhecimentos ou da Memória de Agentes numa aplicação. O objeto
\textbf{read\_memory\textasciitilde} é usado para ler a Memória de
sinais de Áudio de um Atuador ou Sensor de um Agente, e possui
um \textit{outlet} através do qual o \textit{patch} recebe o sinal
de Áudio correspondente ao Componente e intervalo temporal determinados
na inicialização do objeto.

O objeto \textbf{read\_fact} lê da Base de Conhecimentos de um Agente
o Fato cujo nome de identificação é definido em sua inicialização, ou
através de mensagens. O \textit{patch} acessa esse Fato através do
\textit{outlet} deste objeto.

\subsection{Código e Documentação}

O código e a documentação do Arcabouço Ensemble podem ser encontrados
respectivamente em~\cite{ensemblecode} e~\cite{ensembledoc}.
O projeto tem uma página~\cite{ensemblegrouppage} no site do Grupo de Computação 
Musical do IME, e o código pode ser obtido seguindo as instruções na própria página
onde está hospedado.

\newpage
\subsection{Diagrama de Classes}\label{sec:diagrama}

\end{multicols}
\begin{figure}[H]
  \centering
  %\includegraphics[scale=0.39]{./class_diag.jpg}
  \label{fig2}
\end{figure}
\begin{multicols}{2}

\newpage
\section{Disciplinas Cursadas}

Durante o semestre, foram cursadas três disciplinas no IME.
Esta seção fará um breve comentário sobre cada uma delas.

\subsection{Conceitos Fundamentais de Linguagens de Programação}

Nesta disciplina foi construída uma linguagem de programação muito
simples, sobre a linguagem \textit{Racket}. No processo, estudou-se
as estruturas sintáticas e semânticas necessárias para a elaboração
de uma linguagem de programação, por meio da implementação dessas
estruturas. A linguagem no estado final contém, por exemplo,
implementações de Funções, Objetos, Ambientes e Escopos.

\subsection{Laboratório de Programação Extrema}

Aborda metodologias de desenvolvimento de software, e as
diversas técnicas e ferramentas aprendidas são exercitadas em
um projeto real. Contribuiu para o Projeto de Iniciação Científica
do aluno com noções de planejamento, organização e integração contínua
no processo de desenvolvimento de software.

\subsection{Princípios de Interação Humano-Computador}

Esta disciplina estuda o planejamento de interfaces de software voltadas 
ao usuário, os conceitos e ferramentas abordados também são exercitados
em um projeto de desenvolvimento de interface. Esta disciplina contribui com
os objetivos do Projeto de Iniciação Científica desenvolvido pelo aluno,
pois abordou princípios de elaboração de interfaces e de design centrado
no usuário.

\end{multicols}

\newpage
\bibliographystyle{plain}
\bibliography{Projeto}

\end{document}
