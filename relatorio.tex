\documentclass[a4paper, 11pt, twoside]{article}

\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{a4wide}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{textcomp}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\pdobject}[1]{\begin{center}\fbox{\texttt{#1}}\end{center}}

\begin{document}

\hypersetup{backref,pdfpagemode=FullScreen,colorlinks=true}

\input{./title.tex}

\tableofcontents
\newpage

\begin{abstract}
\line(1,0){350}

A adaptabilidade em tempo real e o potencial de modelagem de sistemas complexos
são características de Sistemas Multiagentes, que têm variadas aplicações no 
contexto musical. A ferramenta de criação musical e linguagem de programação 
Pure Data (Pd) é tradicionalmente utilizada por músicos em performances 
musicais. Este projeto produziu uma integração do arcabouço para Sistemas
Multiagentes Musicais Ensemble - implementado pelo Grupo de Computação Musical 
do IME/USP - com a libpd, uma infraestrutura do tipo API para Pure Data. 
A integração procura facilitar a utilização do arcabouço por usuários 
não programadores. A interface é uma extensão do Arcabouço Ensemble,
e permite desenvolver aplicações do Arcabouço através do ambiente gráfico
do Pure Data.

\line(1,0){350}
\end{abstract}

\begin{multicols}{2}

\section{Introdução}

Este relatório descreve e detalha as atividades desenvolvidas no período de 
Fevereiro a Julho de 2014, sumarizadas a seguir.

O aluno apresentou um seminário sobre o trabalho desenvolvido na elaboração da 
interface entre a linguagem de programação Pure Data e o Arcabouço Ensemble, 
no ciclo aberto de seminários do Grupo de Computação Musical.

Elaborou-se um protocolo de comunicação entre o Arcabouço Ensemble e o
Pure Data, permitindo a comunicação entre \textit{patches} e o Arcabouço.

A interface de comunicação básica implementada no semestre passado foi
largamente extendida durante este semestre, permitindo a definição de
Agentes Musicais, seus Raciocínios e Componentes e até aplicações
completas do Arcabouço Ensemble através de \textit{patches} Pure Data.

Submetemos um artigo para a Conferência Conjunta ICMC/SMC 2014~\cite{},
detalhando o protocolo e a interface desenvolvidos. O artigo foi aceito
para publicação e apresentação oral na Conferência.

As próximas seções apresentam o detalhamento destas atividades.

\section{O Protocolo}

Através da implementação da libpd na linguagem Java é possível
realizar a comunicação entre Raciocínios de Agentes inseridos no
Ensemble e \textit{patches} Pure Data. Neste contexto, o Raciocínio
Java serve como encapsulador do \textit{patch}, que contém o Raciocínio em si.

Para que este encapsulamento funcione, a implementação de um \textit{patch} 
para uma aplicação do Ensemble deve seguir um protocolo, usando objetos e
sintaxe bem definidos, para que possa acessar as estruturas contidas nas
representações de Agentes e demais componentes de uma aplicação no Ensemble.
Esse protocolo deve definir objetos Pd para acessar e modificar Memórias
correspondentes a Sensores e Atuadores, e informações na Base de Conhecimentos
de um Agente, pois essas são estruturas e informações essenciais na elaboração
de qualquer Raciocínio. Além disso, o protocolo deve definir objetos para
criação e modificação de Agentes e seus componentes, e dos Ambientes Virtuais
para execução da aplicação. Finalmente, o protocolo deve fornecer acesso às 
configurações disponíveis no arquivo XML de configuração e inicialização.

O protocolo definido a seguir procura permitir que aplicações Ensemble sejam
configuradas sem a necessidade de conhecimento da implementação do Arcabouço
em Java. Idealmente, não deve ser necessário que o usuário do Ensemble-Pd
tome conhecimento da troca de informações e mensagens entre seu \textit{patch}
Pd e o código Java do Ensemble.

\subsection{Ambiente}

Aplicações do Ensemble podem ser configuradas através de um arquivo XML
processado por uma classe de inicialização, onde o usuário define os
componentes e parâmetros de sua aplicação, como Servidores de Eventos,
Mundos e Leis, Agente Musicais e seus Componentes. A interface Ensemble-Pd
permite que esses parâmetros sejam definidos através dos argumentos de 
mensagens enviadas a símbolos no Pd no momento de inicialização do 
\textit{patch} pela instância do Pd executada no Ensemble.

Mensagens enviadas ao símbolo \textbf{global} definem o modo de
execução do relógio interno, processamento e agendamento do Ensemble;
mensagens enviadas ao símbolo \textbf{environment} definem o Agente Ambiente,
Mundo e Leis; e mensagens enviadas ao símbolo \textbf{add\_agent} definem os
nomes dos Agentes que devem ser adicionados à aplicação, cuja definição deve
estar em \textit{subpatches} ou abstrações dentro do patch de configuração.

A Tabela\ref{tab:startupsymbols} apresenta os objetos Pd utilizados no momento
da inicialização, seu uso e parâmetros.

\end{multicols}

\begin{table}[h]
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            Símbolo/Objeto & Argumentos & Uso \\
            \hline
        \textbf{global} & \begin{tabular}[c]{@{}l@{}}<clock\_mode>\\<process\_mode>\\<scheduler\_threads>\end{tabular} & \begin{tabular}[c]{@{}l@{}}Sets\\execution\\parameters\end{tabular} \\
            \hline   
        \textbf{environment} & \begin{tabular}[c]{@{}l@{}}<class>\\<world>\\<\textit{world\_class}>\\ {[}<\textit{world\_law}>]\end{tabular} & \begin{tabular}[c]{@{}l@{}}Sets\\environment\\and world\\parameters\end{tabular} \\
            \hline
        \textbf{add\_agent} & <name> & \begin{tabular}[c]{@{}l@{}}Adds\\an Agent\end{tabular}\\
            \hline
        \textbf{[r <\textit{agent}>/start]} & & \begin{tabular}[c]{@{}l@{}}Receives\\agent\\startup bang\end{tabular} \\
            \hline   
        \end{tabular}
    \end{center}
    \caption{Símbolos de Inicialização.}
    \label{tab:startupsymbols}
\end{table}

\begin{multicols}{2}

\subsection{Sensores e Atuadores}

Todos os Agentes adicionados a uma aplicação no Ensemble-Pd têm seu próprio
\textit{subpatch} onde são definidos e configurados seu Raciocínio, 
Sensores, Atuadores, Memórias e Base de Conhecimentos. Essas mensagens
de configuração são enviadas ao Ensemble quando o Arcabouço inicializa
os Agentes.

A Tabela\ref{tab:actuatorsandsensors} mostra os símbolos e objetos
Pd utilizados na comunicação e configuração dos Sensores e Atuadores de
um Agente.

\end{multicols}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            Símbolo/Objeto & Argumentos & Uso \\
            \hline
        \textbf{add\_actuator} & \begin{tabular}[c]{@{}l@{}}<name>\\<type>\\ {[}<scope>]\end{tabular} & Adds a new Actuator \\
            \hline   
        \textbf{add\_sensor} & \begin{tabular}[c]{@{}l@{}}<name>\\<type>\\ {[}<scope>]\end{tabular} & Adds a new Sensor \\
            \hline
            \textbf{remove\_actuator} & <name> & Removes an Actuator \\
            \hline
            \textbf{remove\_sensor} & <name> & Removes a Sensor \\
            \hline
        \textbf{[s \textit{actuator\_name}]} & \begin{tabular}[c]{@{}l@{}}<data>\\ {[}<scope>]\end{tabular} & \begin{tabular}[c]{@{}l@{}}Writes data \\ to \textit{actuator\_name}\end{tabular} \\
            \hline
        \textbf{[r \textit{sensor\_name}]} & & \begin{tabular}[c]{@{}l@{}}Receives data\\from \textit{sensor\_name}\end{tabular} \\
            \hline
        \end{tabular}
    \end{center}
    \caption{Símbolos para Atuadores e Sensores.}
    \label{tab:actuatorsandsensors}
\end{table}

\begin{multicols}{2}

O Ensemble inicializa o processamento dos Agentes enviando, através da libpd,
um \textbf{bang} para o símbolo \texttt{<\textit{agent}>/start} 
(veja a Tabela\ref{tab:startupsymbols}), que será recebido no \textit{patch}
através do objeto \pdobject{r <\textit{agent}>/start} ao qual devem estar
conectadas as mensagens de inicialização do Agente.

\subsection{Base de Conhecimentos}

Mensagens enviadas ao símbolo \textbf{new\_fact} adicionam um novo Fato
à Base de Conhecimentos de um Agente, e devem conter um nome e um valor.
Fatos adicionados podem ser recuperados e modificados através dos objetos
Pd \pdobject{read\_fact <agent\_name>} \pdobject{update\_fact <agent\_name>} 

Na Tabela\ref{tab:kbprotocol} estão os símbolos e objetos utilizados no
acesso e modificação da Base de Conhecimentos de um Agente.

\end{multicols}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            Símbolo/Objeto & Argumentos & Uso \\
            \hline
        \textbf{new\_fact} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<value>\end{tabular} & Adds a new Fact\\
            \hline   
        \textbf{update\_fact} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<value>\end{tabular} & \begin{tabular}[c]{@{}l@{}}Updates a\\fact if it\\exists\end{tabular}\\
            \hline
            \textbf{remove\_fact} & name & Removes a Fact\\
            \hline
        \textbf{[read\_fact]} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<value>\end{tabular}
                              & \begin{tabular}[c]{@{}l@{}}Reads a \\Fact and\\returns a value\end{tabular}\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Símbolos para a Base de Conhecimentos.}
    \label{tab:kbprotocol}
\end{table}

\begin{multicols}{2}

\subsection{Memórias}

Da mesma forma, diferentes tipos de Memórias podem ser criadas, acessadas e
modificadas através de mensagens aos símbolos \textbf{new\_memory}, 
\textbf{read\_memory} e \textbf{write\_memory}. 

A Tabela\ref{tab:memprotocol} contém os símbolos e objetos utilizados
pelo protocolo na manipulação de Memórias.

\end{multicols}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            Símbolo/Objeto & Argumentos & Uso \\
            \hline
        \textbf{new\_memory} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<type>\\\end{tabular} & Adds a new Memory \\
            \hline 
        \textbf{write\_memory} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<value>\end{tabular} & \begin{tabular}[c]{@{}l@{}}Writes to a \\Memory at\\current time\end{tabular} \\
            \hline
        \textbf{read\_memory} & \begin{tabular}[c]{@{}l@{}}<agent>\\<name>\\<time>\end{tabular} & \begin{tabular}[c]{@{}l@{}}Reads a \\Memory and\\returns a value\end{tabular} \\
            \hline
        \end{tabular}
    \end{center}
    \caption{Símbolos para Memória.}
    \label{tab:memprotocol}
\end{table}

\begin{multicols}{2}

\section{A Interface}

A interface implementada é composta de uma extensão do Arcabouço Ensemble,
que consiste de várias classes Java e de algumas abstrações Pure Data.
Esta seção descreve com detalhes a implementação das classes e abstrações,
e discute os problemas encontrados e as soluções adotadas.

\subsection{Classes Java}

Esta seção apresenta uma descrição detalhada da interface Ensemble-Pd,
justificando as principais classes Java utilizadas, expondo suas 
interrelações e contextualizando seu papel no funcionamento de aplicações
do Ensemble.

\subsubsection{PdAgent}

Esta classe é uma extensão da classe \textbf{MusicalAgent} do Ensemble,
e suas instâncias representam agentes musicais numa aplicação.
O mapeamento de um agente definido num \textit{patch} e sua representação no 
Ensemble é feito através dessa classe.

A classe \textbf{PdAgentClassInformation} encapsula informações sobre
instâncias de Agentes definidas no \textit{patch}, que são utilizadas na
inicialização do Ensemble para instanciar e cadastrar esses Agentes no
JADE.

Os componentes de um Agente, como Raciocínio, Atuadores e Sensores, são
adicionados a \textbf{PdAgent} através de mensagens definidas dentro do
\textit{patch}. Atuadores e Sensores são representados pelas classes 
\textbf{PdActuator} e \textbf{PdSensor}, respectivamente.

O Servidor de Eventos de uma aplicação Ensemble-Pd é responsável por garantir 
que a representação de um Agente num \textit{patch} receba e envie Eventos, 
Mensagens e Áudio de e para o Ambiente Virtual e outros Agentes. Isso é feito
através de Sensores e Atuadores especiais, inseridos por padrão em instâncias
de \textbf{PdAgent}, e que permitem essa comunicação.

\subsubsection{PdReasoning}

O raciocínio de um Agente numa aplicação Ensemble-Pd é definido dentro do
\textit{subpatch}/abstração correspondente a esse Agente, e consiste de
uma aplicação Pd que pode conter qualquer objeto Pd utilizado em aplicações
tradicionais. De dentro do \textit{patch} de Raciocínio, o programador Pd tem 
acesso à informação recebida pelo Agente através dos Sensores que ele definiu,
podendo utilizar os recursos de Processamento de Sinais implementados no Pure
Data para produzir e processar amostras de áudio e demais informações 
recebidas, e pode atuar no Ambiente Virtual através dos Atuadores do Agente.

\subsubsection{PdEvent}

Esta classe encapsula, no funcionamento de uma aplicação Ensemble,
as mensagens e informações provenientes e destinadas a \textit{patches} Pd.

Os tipos manipulados por esta classe são \textbf{PdFloat}, \textbf{PdMessage} e
\textbf{PdAudioBlock}, que por sua vez encapsulam os diferentes tipos de dados
tratados pelo Pure Data.

\subsubsection{PdServer}

Esta é a principal classe do ponto de vista da sincronização 
e mapeamento entre \textit{patches} e aplicações Ensemble.
Ela é quem centraliza e coordena a execução de um \textit{patch}, utilizando
a classe \textbf{PdProcessor}, e processa as mensagens e dados recebidos do Pd 
através da classe \textbf{PdReceiver}, produzindo Eventos para os Sensores 
dos Agentes a que essas mensagens se destinam.

Além disso, é ela quem processa os Eventos enviados por Atuadores de Agentes,
reproduzindo no \textit{patch} as mudanças feitas pelos Agentes.

\subsubsection{PdReceiver}

Esta é uma extensão da classe \textbf{PdDispatcher} contida na implementação
Java da libpd, e encapsula as funções de \textit{callback} usadas na
comunicação entre \textit{patches} e aplicações que usam a libpd.

Esta classe também é responsável por registrar e gerenciar símbolos
usados na comunicação do Ensemble com o \textit{patch}, centralizando
o envio e recebimento de mensagens, áudio e demais informações.

A padronização dos símbolos utilizados nos componentes e mensagens
de uma aplicação Ensemble-Pd permite que o ciclo de processamento
dos \textit{patches} de aplicação seja centralizado pela classe
\textbf{PdServer}, pois garante que não haverão ambiguidades entre
destinatários/remetentes e que nenhuma mensagem será perdida
entre ciclos de processamento.

\subsubsection{PdAudioBlock}

Durante a implementação da interface, desenvolvemos duas diferentes estratégias
para a transferência de amostras de áudio entre o \textit{patch} e o Ensemble, 
uma centralizada e uma distribuída, finalmente optando pela centralização 
do ciclo de processamento na classe \textbf{PdServer}.

A estratégia distribuída consistia na descentralização dos ciclos de
processamento da libpd, permitindo que cada Raciocínio de um Agente
inserido numa aplicação processasse seu \textit{subpatch} independentemente,
tratando suas próprias mensagens e amostras de áudio separadamente.

Essa estratégia gera problemas de sincronização de Eventos e Áudio,
decorrentes do funcionamento dos dois softwares envolvidos.

As amostras de áudio produzidas num mesmo momento pelos Agentes 
num \textit{patch} devem ser tocadas como seriam num \textit{patch}
processado pelo Pd, e as mensagens enviadas pelos Agentes devem obedecer
uma sequência definida pelo Raciocínio, também definido num \textit{patch}.
Se cada Agente é capaz de processar o \textit{patch} de aplicação
no seu ciclo de processamento no Ensemble, não é possível garantir que ele
não receberá ou enviará Eventos ou Áudio somente após todos os outros Agentes 
recebam seu "turno" de Eventos, pois o controle de tempo execução dos Agentes 
é feito pelo middleware JADE, e não tem conexão com o ciclo de processamento
da libpd.

Como o \textit{patch} de configuração de aplicação é único, o controle de
processamento descentralizado produz desencontros nas amostras de Áudio, 
e também no fluxo de Eventos da aplicação.

A solução de processamento centralizado resolve estes problemas utilizando
as abstrações Pd \textbf{act\textasciitilde} e \textbf{sense\textasciitilde},
e as classes Java \textbf{PdAudioBlock} e \textbf{PdAudioBlockStream}.

Essas classes representam um bloco de processamento do Pure Data, e um
encadeamento temporal desses blocos, respectivamente. Elas permitem
receber amostras de Áudio de cada Atuador independentemente, e enviar
amostras a Sensores de forma sincronizada, pois cada Sensor e Atuador
tem seu próprio \textbf{PdAudioBlockStream}.

O Servidor de Eventos pode então enviar e receber Áudio e Eventos de Agentes,
mantendo a sincronia entre a execução do Ensemble e o processamento 
do \textit{patch}.

\subsection{Abstrações no Pure Data}

Em conjunto com as classes Java foram implementadas abstrações do
Pure Data, que são facilitadores da comunicação entre Ensemble e Pd
e encapsulam o uso dos componentes de baixo-nível fornecidos pela
interface Ensemble-libpd em  novos componentes de alto-nível
na forma de objetos Pure Data.

O programador Pd pode então utilizar esses objetos para se comunicar
com o Ensemble utilizando as convenções da linguagem Pure Data,
sem se preocupar com detalhes de implementação da interface com o
Ensemble.

\subsubsection{act\textasciitilde e sense\textasciitilde}

Um Atuador de um Agente numa aplicação é representado pela abstração
\textbf{act\textasciitilde}, e recebe através de um \textit{inlet} 
um sinal de Áudio que será propagados no Ambiente 
Virtual e percebidos por outros Agentes de acordo com as regras da aplicação. 
De forma análoga, a abstração \textbf{sense\textasciitilde} possui um 
\textit{outlet} através do qual o \textit{patch} recebe os sinais de Áudio 
percebidos pelo Agente correspondente.

As abstrações \textbf{act} e \textbf{sense}, seguindo a convenção de nomes do
Pure Data, são utilizadas para a comunicação dos demais tipos de dados.

\subsubsection{read\_memory\textasciitilde e read\_fact}

Estas abstrações são utilizadas para acessar informações da Base
de Conhecimentos ou da Memória de Agentes numa aplicação. O objeto
\textbf{read\_memory\textasciitilde} é usado para ler a Memória de
sinais de Áudio de um Atuador ou Sensor de um Agente, e possui
um \textit{outlet} através do qual o \textit{patch} recebe o sinal
de Áudio correspondente ao Componente e intervalo temporal determinados
na inicialização do objeto.

O objeto \textbf{read\_fact} lê da Base de Conhecimentos de um Agente
o Fato cujo nome de identificação é definido em sua inicialização, ou
através de mensagens. O \textit{patch} acessa esse Fato através do
\textit{outlet} deste objeto.

\subsection{Código e Documentação}

O código e a documentação do Arcabouço Ensemble podem ser encontrados
respectivamente em~\cite{ensemblecode} e~\cite{ensembledoc}.
O projeto tem uma página~\cite{ensemblegrouppage} no site do Grupo de Computação 
Musical do IME, e o código pode ser obtido seguindo as instruções na própria página
onde está hospedado.

\newpage
\subsection{Diagrama de Classes}\label{sec:diagrama}

\end{multicols}
\begin{figure}[H]
  \centering
  %\includegraphics[scale=0.39]{./class_diag.jpg}
  \label{fig2}
\end{figure}
\begin{multicols}{2}

\newpage
\section{Disciplinas Cursadas}

Durante o semestre, foram cursadas três disciplinas no IME.
Esta seção fará um breve comentário sobre cada uma delas.

\subsection{Conceitos Fundamentais de Linguagens de Programação}

Nesta disciplina foi construída uma linguagem de programação muito
simples, sobre a linguagem \textit{Racket}. No processo, estudou-se
as estruturas sintáticas e semânticas necessárias para a elaboração
de uma linguagem de programação, por meio da implementação dessas
estruturas. A linguagem no estado final contém, por exemplo,
implementações de Funções, Objetos, Ambientes e Escopos.

\subsection{Laboratório de Programação Extrema}

Aborda metodologias de desenvolvimento de software, e as
diversas técnicas e ferramentas aprendidas são exercitadas em
um projeto real. Contribuiu para o Projeto de Iniciação Científica
do aluno com noções de planejamento, organização e integração contínua
no processo de desenvolvimento de software.

\subsection{Princípios de Interação Humano-Computador}

Esta disciplina estuda o planejamento de interfaces de software voltadas 
ao usuário, os conceitos e ferramentas abordados também são exercitados
em um projeto de desenvolvimento de interface. Esta disciplina contribui com
os objetivos do Projeto de Iniciação Científica desenvolvido pelo aluno,
pois abordou princípios de elaboração de interfaces e de design centrado
no usuário.

\end{multicols}

\newpage
\bibliographystyle{plain}
\bibliography{Projeto}

\end{document}
